#Flatmap doest not maitains ordering
#While concatMap mantains ordering

#FlatMapMany used to perform flatmap operation on mono , when we want to return flux (mono to flux conversion)

#trasform operator is another way to achieve filter operation.

#DefaultIfEmpty is used to handle empty scenario like String length grater than 10 is not exist during filter operation then we use this operator .
#SwitchIfEmpty is used when there is no data is emitted while checking using DefaultIfEmpty

#Concat and ConcatWith : join two or more Flux or Mono
#Merge and mergeWith : join two or more Flux or Mono and return result asynschronously

#mergeSequential : join two or more Flux or Mono and return result synschronously/ Sequentially
#Zip and ZipWith : To work with different types of reactive types like , Flux<String> with Flux<Integer> or concating two Fluxes. .

#DoOn : print the next value from publisher


#Exception handling
#OnErrorReturn
#OnErrorContinue
#onErrorMap : used to map custom exceptions based on business exceptions , stops the next element to publish once exception occured
#doOnError

#In microservice architecture when there is issue occurs while fetching, from service then we have to apply retry
#retry() : It will continuously retries , and this should not be used
#retry(n) : use n as number of retries
#retryWhen() : retry for particular scenario

#BackPressure : It is used when we wanted to , send some amount of data to receiver then we use it.
#onBackPressureDrop() : It is used to check where the other data is gone apart from the published data
#onBackPressureBuffer() : Prints total buffered size values to consumer/receiver
#onBackPressureError() : displays the error occured due to receiver needed few records/data sent from emitter

#Hot and Cold Streams
#Cold Streams : When emitter send full data, whenever needed then it is known as cold stream. Every subscriber will get definite amount of data .
#hot streams: When emitter send data at particular interval of time . example :stocks,sports score


